/**
 * useBudgetIntelligence Hook - BazarKELY
 * Hook personnalis√© pour l'int√©gration du service d'intelligence budg√©taire
 * 
 * @version 1.0
 * @date 2025-01-11
 * @author BazarKELY Team
 * 
 * @example
 * ```tsx
 * const {
 *   intelligentBudgets,
 *   budgetAnalysis,
 *   deviationAlerts,
 *   isCalculating,
 *   acceptSuggestedBudgets,
 *   customizeBudget,
 *   dismissAlert,
 *   recalculateBudgets
 * } = useBudgetIntelligence();
 * ```
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { toast } from 'react-hot-toast';
import { useAppStore } from '../stores/appStore';
import apiService from '../services/apiService';
import type {
  CategoryBudgets,
  BudgetAnalysis,
  DeviationAlert
} from '../services/budgetIntelligenceService.ts';
import {
  analyzePriorityAnswers,
  analyzeTransactionHistory,
  detectSpendingDeviation,
  calculateAdjustedBudgets
} from '../services/budgetIntelligenceService.ts';
import type { Transaction } from '../types/index.js';

/**
 * Interface pour le retour du hook useBudgetIntelligence
 */
export interface UseBudgetIntelligenceReturn {
  readonly intelligentBudgets: CategoryBudgets | null;
  readonly budgetAnalysis: BudgetAnalysis | null;
  readonly deviationAlerts: readonly DeviationAlert[];
  readonly isCalculating: boolean;
  readonly acceptSuggestedBudgets: () => void;
  readonly customizeBudget: (category: string, newAmount: number) => void;
  readonly dismissAlert: (alertId: string) => void;
  readonly recalculateBudgets: () => void;
}

/**
 * Hook personnalis√© pour l'intelligence budg√©taire
 * G√®re les calculs automatiques, les ajustements et les alertes de d√©viation
 */
export default function useBudgetIntelligence(): UseBudgetIntelligenceReturn {
  // √âtat du hook
  const [intelligentBudgets, setIntelligentBudgets] = useState<CategoryBudgets | null>(null);
  const [budgetAnalysis, setBudgetAnalysis] = useState<BudgetAnalysis | null>(null);
  const [deviationAlerts, setDeviationAlerts] = useState<readonly DeviationAlert[]>([]);
  const [lastCalculationDate, setLastCalculationDate] = useState<Date | null>(null);
  const [isCalculating, setIsCalculating] = useState<boolean>(false);
  const [hasAutoCreated, setHasAutoCreated] = useState<boolean>(false);

  // Acc√®s au store
  const user = useAppStore((state) => state.user);
  const setUser = useAppStore((state) => state.setUser);
  
  // √âtat pour les transactions
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [isLoadingTransactions, setIsLoadingTransactions] = useState<boolean>(false);

  // Refs pour √©viter les re-calculs excessifs
  const dailyCheckTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastDailyCheckRef = useRef<Date | null>(null);

  /**
   * Charge les transactions de l'utilisateur depuis la base de donn√©es
   */
  const loadTransactions = useCallback(async (): Promise<void> => {
    if (!user) {
      console.log('‚ùå DEBUG loadTransactions - Pas d\'utilisateur connect√©');
      setTransactions([]);
      setIsLoadingTransactions(false);
      return;
    }

    console.log('üîÑ DEBUG loadTransactions - D√©but du chargement des transactions depuis Supabase pour utilisateur:', user.id);
    setIsLoadingTransactions(true);
    
    try {
      // Utiliser apiService.getTransactions() comme DashboardPage
      const response = await apiService.getTransactions();
      
      if (!response.success || response.error) {
        console.error('‚ùå DEBUG loadTransactions - Erreur API:', response.error);
        setTransactions([]);
        setIsLoadingTransactions(false);
        return;
      }
      
      // Transformer les donn√©es Supabase vers le format Transaction
      const supabaseTransactions = response.data as any[];
      const userTransactions: Transaction[] = supabaseTransactions.map((t: any) => ({
        id: t.id,
        userId: t.user_id,
        accountId: t.account_id,
        type: t.type,
        amount: t.amount,
        description: t.description,
        category: t.category,
        date: new Date(t.date),
        targetAccountId: t.target_account_id,
        notes: t.notes || undefined,
        createdAt: new Date(t.created_at)
      }));
      
      console.log('üìä DEBUG loadTransactions - Transactions charg√©es depuis Supabase:', userTransactions.length);
      console.log('üí∞ DEBUG loadTransactions - Types de transactions:', userTransactions.map(t => t.type));
      console.log('üìÖ DEBUG loadTransactions - P√©riode des transactions:', {
        plus_ancienne: userTransactions.length > 0 ? new Date(Math.min(...userTransactions.map(t => new Date(t.date).getTime()))).toISOString() : 'Aucune',
        plus_recente: userTransactions.length > 0 ? new Date(Math.max(...userTransactions.map(t => new Date(t.date).getTime()))).toISOString() : 'Aucune'
      });
      
      setTransactions(userTransactions);
      console.log('‚úÖ DEBUG loadTransactions - Chargement termin√©, transactions mises √† jour');
    } catch (error) {
      console.error('‚ùå DEBUG loadTransactions - Erreur lors du chargement des transactions:', error);
      setTransactions([]);
    } finally {
      setIsLoadingTransactions(false);
    }
  }, [user]);

  /**
   * Calcule les budgets bas√©s sur les revenus mensuels (fallback quand priorityAnswers manquants)
   */
  const calculateIncomeBasedBudgets = useCallback((): CategoryBudgets | null => {
    console.log('üîÑ DEBUG calculateIncomeBasedBudgets - D√©but du calcul bas√© sur les revenus');
    console.log('üìä DEBUG - Nombre de transactions disponibles:', transactions.length);

    if (transactions.length === 0) {
      console.log('‚ö†Ô∏è DEBUG calculateIncomeBasedBudgets - Aucune transaction disponible');
      return null;
    }

    try {
      // Obtenir le mois et l'ann√©e actuels
      const currentDate = new Date();
      const currentYear = currentDate.getFullYear();
      const currentMonth = currentDate.getMonth();

      console.log('üìÖ DEBUG calculateIncomeBasedBudgets - P√©riode analys√©e:', {
        year: currentYear,
        month: currentMonth + 1
      });

      // Filtrer les transactions de revenus du mois en cours
      const currentMonthIncomeTransactions = transactions.filter(transaction => {
        const transactionDate = new Date(transaction.date);
        return transaction.type === 'income' &&
               transactionDate.getMonth() === currentMonth &&
               transactionDate.getFullYear() === currentYear;
      });

      console.log('üí∞ DEBUG calculateIncomeBasedBudgets - Transactions de revenus trouv√©es:', currentMonthIncomeTransactions.length);

      if (currentMonthIncomeTransactions.length === 0) {
        console.log('‚ö†Ô∏è DEBUG calculateIncomeBasedBudgets - Aucune transaction de revenu pour le mois en cours');
        return null;
      }

      // Calculer le revenu total du mois
      const totalMonthlyIncome = currentMonthIncomeTransactions.reduce((sum, transaction) => 
        sum + transaction.amount, 0
      );

      console.log('üíµ DEBUG calculateIncomeBasedBudgets - Revenu mensuel total:', totalMonthlyIncome.toLocaleString('fr-FR'), 'Ar');

      if (totalMonthlyIncome <= 0) {
        console.log('‚ö†Ô∏è DEBUG calculateIncomeBasedBudgets - Revenu mensuel invalide ou nul');
        return null;
      }

      // Allocation budg√©taire standard (m√™me que dans budgetIntelligenceService)
      const standardAllocation = {
        Alimentation: 0.36,    // 36%
        Logement: 0.24,        // 24%
        Transport: 0.10,       // 10%
        Communication: 0.05,   // 5%
        Sant√©: 0.05,           // 5%
        √âducation: 0.10,       // 10%
        Loisirs: 0.03,         // 3%
        Habillement: 0.02,     // 2%
        Solidarit√©: 0.05,      // 5%
        √âpargne: 0.00,         // 0% (calcul√© dynamiquement)
        Autres: 0.00           // 0%
      };

      // Calculer l'√©pargne recommand√©e (10% du revenu)
      const savingsAmount = Math.round(totalMonthlyIncome * 0.10);
      const availableForSpending = totalMonthlyIncome - savingsAmount;

      // Calculer les budgets pour chaque cat√©gorie
      const budgets: CategoryBudgets = {
        Alimentation: Math.round(availableForSpending * standardAllocation.Alimentation),
        Logement: Math.round(availableForSpending * standardAllocation.Logement),
        Transport: Math.round(availableForSpending * standardAllocation.Transport),
        Communication: Math.round(availableForSpending * standardAllocation.Communication),
        Habillement: Math.round(availableForSpending * standardAllocation.Habillement),
        Sant√©: Math.round(availableForSpending * standardAllocation.Sant√©),
        √âducation: Math.round(availableForSpending * standardAllocation.√âducation),
        Loisirs: Math.round(availableForSpending * standardAllocation.Loisirs),
        Solidarit√©: Math.round(availableForSpending * standardAllocation.Solidarit√©),
        √âpargne: savingsAmount,
        Autres: Math.round(availableForSpending * standardAllocation.Autres)
      };

      console.log('‚úÖ DEBUG calculateIncomeBasedBudgets - Budgets calcul√©s:');
      Object.entries(budgets).forEach(([category, amount]) => {
        console.log(`  ${category}: ${amount.toLocaleString('fr-FR')} Ar`);
      });

      const totalBudgets = Object.values(budgets).reduce((sum, amount) => sum + amount, 0);
      console.log('üí∞ DEBUG calculateIncomeBasedBudgets - Total des budgets:', totalBudgets.toLocaleString('fr-FR'), 'Ar');
      console.log('üìä DEBUG calculateIncomeBasedBudgets - Pourcentage du revenu:', ((totalBudgets / totalMonthlyIncome) * 100).toFixed(2) + '%');

      return budgets;

    } catch (error) {
      console.error('‚ùå DEBUG calculateIncomeBasedBudgets - Erreur lors du calcul:', error);
      return null;
    }
  }, [transactions]);

  /**
   * Calcule les budgets intelligents bas√©s sur les r√©ponses prioritaires ou les revenus
   */
  const calculateIntelligentBudgets = useCallback(async (): Promise<void> => {
    console.log('üöÄ DEBUG useBudgetIntelligence - D√©but du calcul des budgets intelligents');
    console.log('üë§ DEBUG - Utilisateur:', user?.id);
    console.log('üìä DEBUG - Nombre de transactions dans le hook:', transactions.length);
    console.log('üìã DEBUG - R√©ponses prioritaires disponibles:', !!user?.preferences?.priorityAnswers);

    try {
      setIsCalculating(true);
      
      let budgets: CategoryBudgets | null = null;
      let calculationMethod = '';

      // Priorit√© aux priorityAnswers si disponibles
      if (user?.preferences?.priorityAnswers) {
        console.log('üéØ DEBUG useBudgetIntelligence - Utilisation des priorityAnswers');
        console.log('üìã DEBUG - R√©ponses prioritaires:', user.preferences.priorityAnswers);
        
        // DEBUG: Verify transactions are passed correctly
        console.log('üîç DEBUG - Transactions array before analyzePriorityAnswers:', {
          length: transactions.length,
          sample: transactions.slice(0, 3).map(t => ({ id: t.id, type: t.type, amount: t.amount, category: t.category }))
        });
        
        budgets = analyzePriorityAnswers(user.preferences.priorityAnswers, transactions);
        calculationMethod = 'priorityAnswers';
        
      } else {
        console.log('üí∞ DEBUG useBudgetIntelligence - Fallback vers calcul bas√© sur les revenus');
        budgets = calculateIncomeBasedBudgets();
        calculationMethod = 'incomeBased';
      }

      if (!budgets) {
        console.log('‚ùå DEBUG useBudgetIntelligence - Aucun budget calcul√©');
        toast.error('Impossible de calculer les budgets. V√©rifiez vos transactions de revenus.');
        return;
      }
      
      console.log('‚úÖ DEBUG useBudgetIntelligence - Budgets calcul√©s via', calculationMethod, ':', budgets);
      
      setIntelligentBudgets(budgets);
      setLastCalculationDate(new Date());

      // Sauvegarde dans le store
      if (user) {
        setUser({
          ...user,
          preferences: {
            ...user.preferences,
            intelligentBudgets: budgets,
            lastBudgetCalculation: new Date()
          }
        });
      }

      const successMessage = calculationMethod === 'priorityAnswers' 
        ? 'Budgets intelligents calcul√©s avec succ√®s !'
        : 'Budgets calcul√©s automatiquement bas√©s sur vos revenus !';
        
      toast.success(successMessage, {
        duration: 3000,
        icon: 'üéØ'
      });

    } catch (error) {
      console.error('Erreur lors du calcul des budgets intelligents:', error);
      toast.error('Erreur lors du calcul des budgets intelligents');
    } finally {
      setIsCalculating(false);
    }
  }, [user, setUser, transactions, calculateIncomeBasedBudgets]);

  /**
   * Effectue une analyse mensuelle et ajuste les budgets si n√©cessaire
   */
  const performMonthlyAnalysis = useCallback(async (): Promise<void> => {
    if (!intelligentBudgets || !transactions.length) {
      return;
    }

    try {
      setIsCalculating(true);

      // Filtrage des transactions du mois dernier
      const lastMonth = new Date();
      lastMonth.setMonth(lastMonth.getMonth() - 1);
      
      const lastMonthTransactions = transactions.filter(transaction => {
        const transactionDate = new Date(transaction.date);
        return transactionDate.getMonth() === lastMonth.getMonth() &&
               transactionDate.getFullYear() === lastMonth.getFullYear();
      });

      if (lastMonthTransactions.length === 0) {
        return;
      }

      // Analyse de l'historique des transactions
      const analysis = analyzeTransactionHistory(lastMonthTransactions, intelligentBudgets);
      setBudgetAnalysis(analysis);

      // V√©rification des tendances coh√©rentes (2+ mois)
      const hasConsistentTrends = analysis.trends.some(trend => trend.months >= 2);
      
      if (hasConsistentTrends) {
        // Calcul des budgets ajust√©s
        const adjustedBudgets = calculateAdjustedBudgets(intelligentBudgets, analysis);
        
        setIntelligentBudgets(adjustedBudgets);
        setLastCalculationDate(new Date());

        // Sauvegarde des budgets ajust√©s
        setUser({
          ...user,
          preferences: {
            ...user.preferences,
            intelligentBudgets: adjustedBudgets,
            lastBudgetCalculation: new Date()
          }
        });

        // Notification des ajustements
        const adjustmentsCount = analysis.recommendations.length;
        toast.success(
          `${adjustmentsCount} budget${adjustmentsCount > 1 ? 's' : ''} ajust√©${adjustmentsCount > 1 ? 's' : ''} automatiquement bas√©${adjustmentsCount > 1 ? 's' : ''} sur vos habitudes de d√©penses`,
          {
            duration: 4000,
            icon: 'üìä'
          }
        );
      }

    } catch (error) {
      console.error('Erreur lors de l\'analyse mensuelle:', error);
      toast.error('Erreur lors de l\'analyse mensuelle des budgets');
    } finally {
      setIsCalculating(false);
    }
  }, [intelligentBudgets, transactions, user, setUser]);

  /**
   * D√©tecte les d√©viations de d√©penses quotidiennes
   */
  const checkDailyDeviations = useCallback(async (): Promise<void> => {
    if (!intelligentBudgets || !transactions.length) {
      return;
    }

    try {
      // Filtrage des transactions du mois en cours
      const currentMonth = new Date();
      const currentMonthTransactions = transactions.filter(transaction => {
        const transactionDate = new Date(transaction.date);
        return transactionDate.getMonth() === currentMonth.getMonth() &&
               transactionDate.getFullYear() === currentMonth.getFullYear();
      });

      if (currentMonthTransactions.length === 0) {
        return;
      }

      // D√©tection des d√©viations
      const alerts = detectSpendingDeviation(currentMonthTransactions, intelligentBudgets);
      
      // Filtrage des alertes de s√©v√©rit√© warning et critical
      const filteredAlerts = alerts.filter(alert => 
        alert.severity === 'warning' || alert.severity === 'critical'
      );

      setDeviationAlerts(filteredAlerts);

      // Notification des alertes critiques
      const criticalAlerts = filteredAlerts.filter(alert => alert.severity === 'critical');
      if (criticalAlerts.length > 0) {
        toast.error(
          `${criticalAlerts.length} alerte${criticalAlerts.length > 1 ? 's' : ''} critique${criticalAlerts.length > 1 ? 's' : ''} d√©tect√©e${criticalAlerts.length > 1 ? 's' : ''}`,
          {
            duration: 5000,
            icon: '‚ö†Ô∏è'
          }
        );
      }

    } catch (error) {
      console.error('Erreur lors de la d√©tection des d√©viations:', error);
    }
  }, [intelligentBudgets, transactions]);

  /**
   * Cr√©e automatiquement les budgets en base de donn√©es
   */
  const autoCreateBudgets = useCallback(async (): Promise<void> => {
    console.log('üîç DEBUG autoCreateBudgets - Function called');
    console.log('üîç DEBUG autoCreateBudgets - intelligentBudgets:', !!intelligentBudgets);
    console.log('üîç DEBUG autoCreateBudgets - user:', !!user);
    console.log('üîç DEBUG autoCreateBudgets - hasAutoCreated:', hasAutoCreated);
    
    if (!intelligentBudgets || !user || hasAutoCreated) {
      console.log('‚ùå DEBUG autoCreateBudgets - Early return due to conditions');
      return;
    }

    console.log('üöÄ DEBUG autoCreateBudgets - D√©but de la cr√©ation automatique des budgets');
    console.log('üìä DEBUG - Nombre de budgets √† cr√©er:', Object.keys(intelligentBudgets).length);
    console.log('üë§ DEBUG - Utilisateur:', user.id);
    console.log('üìã DEBUG - intelligentBudgets content:', intelligentBudgets);

    try {
      const currentDate = new Date();
      const currentYear = currentDate.getFullYear();
      const currentMonth = currentDate.getMonth() + 1;

      console.log('üîç DEBUG autoCreateBudgets - V√©rification des budgets existants pour la p√©riode:', {
        year: currentYear,
        month: currentMonth
      });

      // V√©rifier si des budgets existent d√©j√† pour la p√©riode actuelle
      const existingBudgetsResponse = await apiService.getBudgets();
      
      if (existingBudgetsResponse.success && existingBudgetsResponse.data) {
        // Filtrer les budgets pour la p√©riode actuelle
        const existingBudgetsForPeriod = existingBudgetsResponse.data.filter(budget => 
          budget.month === currentMonth && budget.year === currentYear
        );
        
        console.log('üîç DEBUG autoCreateBudgets - Budgets existants trouv√©s pour la p√©riode:', existingBudgetsForPeriod.length);
        console.log('üîç DEBUG autoCreateBudgets - D√©tails des budgets existants:', existingBudgetsForPeriod.map(b => ({
          id: b.id,
          category: b.category,
          amount: b.amount,
          month: b.month,
          year: b.year
        })));

        if (existingBudgetsForPeriod.length > 0) {
          console.log('‚ö†Ô∏è DEBUG autoCreateBudgets - Budgets d√©j√† existants pour la p√©riode, cr√©ation ignor√©e');
          console.log('‚ö†Ô∏è DEBUG autoCreateBudgets - Budgets existants d√©tect√©s:', existingBudgetsForPeriod.length);
          
          // Marquer comme cr√©√© automatiquement pour √©viter les tentatives futures
          setHasAutoCreated(true);
          
          console.log('‚úÖ DEBUG autoCreateBudgets - hasAutoCreated d√©fini √† true, aucune cr√©ation effectu√©e');
          return;
        }
      } else {
        console.log('‚ö†Ô∏è DEBUG autoCreateBudgets - Erreur lors de la r√©cup√©ration des budgets existants:', existingBudgetsResponse.error);
        // Continuer avec la cr√©ation m√™me en cas d'erreur de r√©cup√©ration
      }

      console.log('‚úÖ DEBUG autoCreateBudgets - Aucun budget existant trouv√©, proc√©dure de cr√©ation...');

      // Cr√©er les budgets pour chaque cat√©gorie
      const budgetPromises = Object.entries(intelligentBudgets).map(async ([category, amount]) => {
        const budgetData = {
          name: `Budget ${category}`,
          category: category.toLowerCase(),
          amount: amount,
          spent: 0,
          period: 'monthly' as const,
          year: currentYear,
          month: currentMonth,
          alert_threshold: 80, // 80%
          is_active: true,
          user_id: user.id
        };

        console.log('üîç DEBUG autoCreateBudgets - Cr√©ation du budget pour cat√©gorie:', category, 'avec montant:', amount);
        return apiService.createBudget(budgetData);
      });

      console.log('‚è≥ DEBUG autoCreateBudgets - Attente de la cr√©ation de tous les budgets...');
      const results = await Promise.all(budgetPromises);
      
      // V√©rifier les r√©sultats
      const failedBudgets = results.filter(result => !result.success);
      const successfulBudgets = results.filter(result => result.success);
      
      console.log('üìä DEBUG autoCreateBudgets - R√©sultats:', {
        total: results.length,
        successful: successfulBudgets.length,
        failed: failedBudgets.length
      });

      if (failedBudgets.length > 0) {
        console.error('‚ùå DEBUG autoCreateBudgets - √âchec de cr√©ation de budgets:', failedBudgets);
        toast.error(`${failedBudgets.length} budget(s) n'ont pas pu √™tre cr√©√©s automatiquement`);
        return;
      }

      // Marquer comme cr√©√© automatiquement
      setHasAutoCreated(true);
      
      console.log('‚úÖ DEBUG autoCreateBudgets - Tous les budgets cr√©√©s avec succ√®s en base de donn√©es');
      
      toast.success('Budgets cr√©√©s automatiquement avec succ√®s !', {
        duration: 4000,
        icon: 'üéØ'
      });

    } catch (error) {
      console.error('‚ùå DEBUG autoCreateBudgets - Erreur lors de la cr√©ation automatique des budgets:', error);
      toast.error('Erreur lors de la cr√©ation automatique des budgets');
    }
  }, [intelligentBudgets, user, hasAutoCreated]);

  /**
   * V√©rifie si c'est un nouveau mois
   */
  const isNewMonth = useCallback((): boolean => {
    if (!lastCalculationDate) {
      return true;
    }

    const now = new Date();
    const lastCalc = new Date(lastCalculationDate);
    
    return now.getMonth() !== lastCalc.getMonth() || 
           now.getFullYear() !== lastCalc.getFullYear();
  }, [lastCalculationDate]);

  /**
   * V√©rifie si la v√©rification quotidienne doit √™tre effectu√©e
   */
  const shouldRunDailyCheck = useCallback((): boolean => {
    const now = new Date();
    const currentHour = now.getHours();
    
    // V√©rification quotidienne √† 8h du matin
    if (currentHour !== 8) {
      return false;
    }

    // √âviter les v√©rifications multiples le m√™me jour
    if (lastDailyCheckRef.current) {
      const lastCheck = new Date(lastDailyCheckRef.current);
      const today = new Date();
      
      return lastCheck.getDate() !== today.getDate() ||
             lastCheck.getMonth() !== today.getMonth() ||
             lastCheck.getFullYear() !== today.getFullYear();
    }

    return true;
  }, []);

  // Effect 0: Chargement des transactions quand l'utilisateur change
  useEffect(() => {
    console.log('üîÑ DEBUG useBudgetIntelligence - Chargement des transactions pour utilisateur:', user?.id);
    loadTransactions();
  }, [loadTransactions]);

  // Effect 1: Calcul initial des budgets quand les r√©ponses prioritaires ou transactions changent
  useEffect(() => {
    console.log('üîÑ DEBUG useBudgetIntelligence - Effect 1 d√©clench√©');
    console.log('üìä DEBUG - Transactions disponibles:', transactions.length);
    console.log('üìã DEBUG - R√©ponses prioritaires:', !!user?.preferences?.priorityAnswers);
    console.log('üí∞ DEBUG - Budgets intelligents existants:', !!intelligentBudgets);
    console.log('‚è≥ DEBUG - Chargement des transactions en cours:', isLoadingTransactions);
    
    // Attendre que les transactions soient charg√©es ET que les conditions soient remplies
    // Priorit√© aux priorityAnswers si disponibles, sinon utiliser les revenus des transactions
    if (user && 
        !intelligentBudgets && 
        !isLoadingTransactions) {
      console.log('üöÄ DEBUG useBudgetIntelligence - Conditions remplies, lancement du calcul des budgets');
      console.log('üìä DEBUG - Transactions count:', transactions.length);
      console.log('üìã DEBUG - PriorityAnswers available:', !!user?.preferences?.priorityAnswers);
      calculateIntelligentBudgets();
    } else if (isLoadingTransactions) {
      console.log('‚è≥ DEBUG useBudgetIntelligence - En attente du chargement des transactions...');
    } else if (!user) {
      console.log('‚ö†Ô∏è DEBUG useBudgetIntelligence - Pas d\'utilisateur connect√©');
    } else if (intelligentBudgets) {
      console.log('‚ÑπÔ∏è DEBUG useBudgetIntelligence - Budgets d√©j√† calcul√©s');
    }
  }, [user, intelligentBudgets, calculateIntelligentBudgets, transactions, isLoadingTransactions]);

  // Effect 1.5: Cr√©ation automatique des budgets quand intelligentBudgets est calcul√©
  useEffect(() => {
    console.log('üîÑ DEBUG useBudgetIntelligence - Effect 1.5 d√©clench√© (cr√©ation automatique)');
    console.log('üí∞ DEBUG - intelligentBudgets:', !!intelligentBudgets);
    console.log('üí∞ DEBUG - intelligentBudgets length:', intelligentBudgets ? Object.keys(intelligentBudgets).length : 0);
    console.log('üë§ DEBUG - user:', !!user);
    console.log('üë§ DEBUG - user id:', user?.id);
    console.log('üîß DEBUG - hasAutoCreated:', hasAutoCreated);
    
    // D√©clencher la cr√©ation automatique si:
    // - intelligentBudgets existe et a des budgets
    // - user existe
    // - pas encore cr√©√© automatiquement
    if (intelligentBudgets && 
        Object.keys(intelligentBudgets).length > 0 && 
        user && 
        !hasAutoCreated) {
      console.log('üöÄ DEBUG useBudgetIntelligence - Conditions remplies pour cr√©ation automatique');
      console.log('üöÄ DEBUG useBudgetIntelligence - Calling autoCreateBudgets()');
      autoCreateBudgets();
    } else if (hasAutoCreated) {
      console.log('‚ÑπÔ∏è DEBUG useBudgetIntelligence - Budgets d√©j√† cr√©√©s automatiquement');
    } else if (!intelligentBudgets) {
      console.log('‚ö†Ô∏è DEBUG useBudgetIntelligence - Pas de budgets intelligents √† cr√©er');
    } else if (!user) {
      console.log('‚ö†Ô∏è DEBUG useBudgetIntelligence - Pas d\'utilisateur pour cr√©ation automatique');
    } else if (intelligentBudgets && Object.keys(intelligentBudgets).length === 0) {
      console.log('‚ö†Ô∏è DEBUG useBudgetIntelligence - intelligentBudgets est vide');
    }
  }, [intelligentBudgets, user, hasAutoCreated, autoCreateBudgets]);

  // Effect 2: V√©rification mensuelle le premier jour du mois
  useEffect(() => {
    const checkMonthly = () => {
      if (isNewMonth() && intelligentBudgets) {
        performMonthlyAnalysis();
      }
    };

    // V√©rification imm√©diate
    checkMonthly();

    // V√©rification quotidienne √† minuit
    const now = new Date();
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    
    const timeUntilMidnight = tomorrow.getTime() - now.getTime();
    
    const timeoutId = setTimeout(() => {
      checkMonthly();
      // R√©p√©ter toutes les 24h
      const intervalId = setInterval(checkMonthly, 24 * 60 * 60 * 1000);
      
      return () => clearInterval(intervalId);
    }, timeUntilMidnight);

    return () => clearTimeout(timeoutId);
  }, [isNewMonth, intelligentBudgets, performMonthlyAnalysis]);

  // Effect 3: V√©rification quotidienne des d√©viations
  useEffect(() => {
    const checkDaily = () => {
      if (shouldRunDailyCheck()) {
        checkDailyDeviations();
        lastDailyCheckRef.current = new Date();
      }
    };

    // V√©rification imm√©diate si n√©cessaire
    checkDaily();

    // V√©rification toutes les heures
    const intervalId = setInterval(checkDaily, 60 * 60 * 1000);

    return () => {
      clearInterval(intervalId);
      if (dailyCheckTimeoutRef.current) {
        clearTimeout(dailyCheckTimeoutRef.current);
      }
    };
  }, [shouldRunDailyCheck, checkDailyDeviations]);

  /**
   * Accepte les budgets sugg√©r√©s et les applique
   */
  const acceptSuggestedBudgets = useCallback((): void => {
    if (!intelligentBudgets || !user) {
      toast.error('Aucun budget intelligent disponible');
      return;
    }

    try {
      setUser({
        ...user,
        preferences: {
          ...user.preferences,
          activeBudgets: intelligentBudgets
        }
      });

      toast.success('Budgets intelligents appliqu√©s avec succ√®s !', {
        duration: 3000,
        icon: '‚úÖ'
      });

      // Effacement des alertes de d√©viation
      setDeviationAlerts([]);

    } catch (error) {
      console.error('Erreur lors de l\'application des budgets:', error);
      toast.error('Erreur lors de l\'application des budgets');
    }
  }, [intelligentBudgets, user, setUser]);

  /**
   * Personnalise un budget pour une cat√©gorie sp√©cifique
   */
  const customizeBudget = useCallback((category: string, newAmount: number): void => {
    if (!intelligentBudgets || !user) {
      toast.error('Aucun budget intelligent disponible');
      return;
    }

    try {
      const currentTotal = Object.values(intelligentBudgets).reduce((sum, amount) => sum + amount, 0);
      const categoryKey = category as keyof CategoryBudgets;
      const currentAmount = intelligentBudgets[categoryKey];
      const difference = newAmount - currentAmount;

      // Calcul des nouveaux budgets
      const newBudgets = { ...intelligentBudgets };
      newBudgets[categoryKey] = newAmount;

      // Ajustement proportionnel des cat√©gories flexibles
      const flexibleCategories: (keyof CategoryBudgets)[] = ['Autres', 'Loisirs'];
      let remainingDifference = difference;

      for (const flexCategory of flexibleCategories) {
        if (remainingDifference === 0) break;
        
        const currentFlexAmount = newBudgets[flexCategory];
        const adjustment = Math.min(Math.abs(remainingDifference), currentFlexAmount);
        
        if (remainingDifference > 0) {
          // R√©duction des cat√©gories flexibles
          newBudgets[flexCategory] = Math.max(0, currentFlexAmount - adjustment);
          remainingDifference -= adjustment;
        } else {
          // Augmentation des cat√©gories flexibles
          newBudgets[flexCategory] = currentFlexAmount + Math.abs(adjustment);
          remainingDifference += adjustment;
        }
      }

      setIntelligentBudgets(newBudgets);

      // Sauvegarde dans le store
      setUser({
        ...user,
        preferences: {
          ...user.preferences,
          intelligentBudgets: newBudgets
        }
      });

      const percentageChange = ((newAmount - currentAmount) / currentAmount) * 100;
      const changeText = percentageChange > 0 ? `+${percentageChange.toFixed(1)}%` : `${percentageChange.toFixed(1)}%`;

      toast.success(
        `Budget ${category} ajust√© √† ${newAmount.toLocaleString('fr-FR')} Ar (${changeText})`,
        {
          duration: 3000,
          icon: '‚úèÔ∏è'
        }
      );

    } catch (error) {
      console.error('Erreur lors de la personnalisation du budget:', error);
      toast.error('Erreur lors de la personnalisation du budget');
    }
  }, [intelligentBudgets, user, setUser]);

  /**
   * Supprime une alerte de d√©viation
   */
  const dismissAlert = useCallback((alertId: string): void => {
    setDeviationAlerts(prevAlerts => 
      prevAlerts.filter(alert => `${alert.category}-${alert.severity}` !== alertId)
    );
  }, []);

  /**
   * Recalcule manuellement tous les budgets
   */
  const recalculateBudgets = useCallback((): void => {
    if (user?.preferences?.priorityAnswers) {
      calculateIntelligentBudgets();
    } else {
      toast.error('Veuillez d\'abord r√©pondre aux questions prioritaires');
    }
  }, [user?.preferences?.priorityAnswers, calculateIntelligentBudgets]);

  return {
    intelligentBudgets,
    budgetAnalysis,
    deviationAlerts,
    isCalculating,
    acceptSuggestedBudgets,
    customizeBudget,
    dismissAlert,
    recalculateBudgets
  };
}
